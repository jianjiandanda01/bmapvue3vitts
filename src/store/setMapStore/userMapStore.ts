const mapInfo = userMapInfo();
/**
 * Polygon Â§öËæπÂΩ¢
 * Circle ÂúÜÂΩ¢
 * Rectangle Áü©ÂΩ¢
 * Marker ÂõæÊ†áÁÇπ
 * Label ÊñáÂ≠óÊ†áÁ≠æ
 */
import { markerIconList, labelText } from "/@assets/markerIconList";
import {
  PenType,
  PenDataInfo,
  Pen,
  PenMap,
  getCenterPoint,
} from "/@store/type/PenClass";
import { userInfo } from "os";
export const userMapStore = defineStore("userMapStore", {
  state: () => ({
    mapInfo: {
      drag: true, // ÊòØÂê¶ÂºÄÂêØÊãñÊãΩ
      clickSelect: false, // ÊòØÂê¶ÂçïÊú∫ÈÄâ‰∏≠
      penType: "" as PenType, // ÁîªÁ¨îÁ±ªÂûã
      iconImgId: "", // ÂõæÊ†áÁÇπÂõæÁâáiconKey
      labelInput: "", // Ê†áÊ≥®ÊñáÂ≠óÂÜÖÂÆπ
    }, // Âú∞ÂõæÁ±ªÂ±ûÊÄß
    penTypeMap: [
      { label: "Â§öËæπÂΩ¢", key: "Polygon", icon: "hexagon-one" },
      { label: "ÂúÜÂΩ¢", key: "Circle", icon: "round" },
      { label: "Áü©ÂΩ¢", key: "Rectangle", icon: "square" },
      { label: "Ê†áÊ≥®", key: "Label", icon: "tag-one" },
      { label: "ÂõæÊ†á", key: "Marker", icon: "local-two" },
    ] as { label: string; key: PenType; icon: string }[],
    nameId: 0, // Ëá™Â¢ûID
    penMap: {
      Polygon: {} as { [propName: string]: Pen },
      Circle: {} as { [propName: string]: Pen },
      Rectangle: {} as { [propName: string]: Pen },
      Label: {} as { [propName: string]: Pen },
      Marker: {} as { [propName: string]: Pen },
    },
    selectPen: {
      penType: "" as PenType,
      nameId: "",
      pen: {} as Pen,
    },
  }),
  getters: {},
  actions: {
    // Ê∏≤ÊüìÁªòÂà∂Áâ©
    setPenList(data) {
      if (data === "") {
        return;
      }
      const penData = JSON.parse(data);
      console.log(
        "üöÄ ~ file: userMapStore.ts:53 ~ setPenList ~ penData:",
        penData
      );
      this.nameId = penData.mapInfo.nameId;
      for (const key in penData.Label) {
        if (Object.prototype.hasOwnProperty.call(penData.Label, key)) {
          const element = penData.Label[key];
          const nameId = element.dataInfo.nameId;
          const width = 20;
          const size = new window.BMap.Size(width, width);
          const icon = new window.BMap.Icon("./public/drag.png", size, {
            imageSize: new window.BMap.Size(width, width),
            anchor: new window.BMap.Size(width / 2, width),
          });
          const label = new window.BMap.Label(element.dataInfo.title, {
            offset: new window.BMap.Size(20, 0),
          });
          const Marker = new window.BMap.Marker(
            new window.BMap.Point(element.position.lng, element.position.lat),
            { icon: icon }
          );
          Marker.setIcon(icon);
          Marker.setLabel(label);
          Marker.dataInfo = element.dataInfo;
          this.penMap[element.dataInfo.type][nameId] = Marker;
          this.addPenClick(Marker);
          mapInfo.myMap.addOverlay(Marker);
        }
      }
      for (const key in penData.Circle) {
        if (Object.prototype.hasOwnProperty.call(penData.Circle, key)) {
          const element = penData.Circle[key];
          const nameId = element.dataInfo.nameId;
          const Circle = new window.BMap.Circle(
            new window.BMap.Point(
              element.position.center.lng,
              element.position.center.lat
            ),
            element.position.radius,
            {
              ...mapInfo.polygonOptions,
            }
          );
          Circle.dataInfo = element.dataInfo;
          this.penMap[element.dataInfo.type][nameId] = Circle;
          this.addPenClick(Circle);
          mapInfo.myMap.addOverlay(Circle);
        }
      }
      for (const key in penData.Polygon) {
        if (Object.prototype.hasOwnProperty.call(penData.Polygon, key)) {
          const element = penData.Polygon[key];
          const nameId = element.dataInfo.nameId;
          const points = [];
          element.position.forEach((poin) => {
            points.push(new window.BMap.Point(poin.lng, poin.lat));
          });
          const Polygon = new window.BMap.Polygon(points, {
            ...mapInfo.polygonOptions,
          });
          Polygon.dataInfo = element.dataInfo;
          this.penMap[element.dataInfo.type][nameId] = Polygon;
          this.addPenClick(Polygon);
          mapInfo.myMap.addOverlay(Polygon);
        }
      }
      for (const key in penData.Rectangle) {
        if (Object.prototype.hasOwnProperty.call(penData.Rectangle, key)) {
          const element = penData.Rectangle[key];
          const nameId = element.dataInfo.nameId;
          const points = [];
          element.position.forEach((poin) => {
            points.push(new window.BMap.Point(poin.lng, poin.lat));
          });
          const Polygon = new window.BMap.Polygon(points, {
            ...mapInfo.polygonOptions,
          });
          Polygon.dataInfo = element.dataInfo;
          this.penMap[element.dataInfo.type][nameId] = Polygon;
          this.addPenClick(Polygon);
          mapInfo.myMap.addOverlay(Polygon);
        }
      }
      for (const key in penData.Marker) {
        if (Object.prototype.hasOwnProperty.call(penData.Marker, key)) {
          const element = penData.Marker[key];
          const imgKey = element.dataInfo.iconImgId.split("-")[0];
          const img =
            markerIconList[imgKey].iconList[element.dataInfo.iconImgId];
          const width = 40;
          const size = new window.BMap.Size(width, width);
          const icon = new window.BMap.Icon(`./${img.markerUrl}`, size, {
            imageSize: new window.BMap.Size(width, width),
            anchor: new window.BMap.Size(width / 2, width),
          });
          const Marker = new window.BMap.Marker(
            new window.BMap.Point(element.position.lng, element.position.lat),
            { icon: icon }
          );
          const nameId = element.dataInfo.nameId;
          Marker.setTitle(element.dataInfo.title);
          Marker.dataInfo = element.dataInfo;
          this.addPenClick(Marker);
          this.penMap[element.dataInfo.type][nameId] = Marker;
          mapInfo.myMap.addOverlay(Marker);
        }
      }
    },
    // ÁîªÁ¨îÊ∑ªÂä†click‰∫ã‰ª∂
    addPenClick(pen) {
      pen.addEventListener("click", ({ type, target }) => {
        if (this.mapInfo.clickSelect) {
          this.selectPen.pen = target;
          this.selectPen.penType = target.dataInfo.type;
          this.selectPen.nameId = target.dataInfo.nameId;
          mapInfo.initializationPenStyle();
          mapInfo.setPenStyle(target, true);
        }
      });
    },
    // Â∞ÜÁîªÁ¨îÊîæÂÖ•penMap  ÂàùÂßãÂåñ
    pushPenMap(pen: Pen) {
      const nameId = this.getNameId();
      this.addPenClick(pen);
      pen.dataInfo.type = this.mapInfo.penType;
      pen.dataInfo.show = true; // ÊòæÁ§∫/ÈöêËóè ÂºÄÂÖ≥
      pen.dataInfo.lock = true; // ÈîÅÂÆö/Êé•Ëß¶ÈîÅÂÆö ÂºÄÂÖ≥
      pen.dataInfo.nameId = nameId; // ÁîªÁ¨îID
      pen.dataInfo.buildId = ""; // Âª∫Á≠ëID
      pen.dataInfo.deviceId = ""; // ËÆæÂ§áID
      pen.dataInfo.HLId = ""; // ÂõûË∑ØÂè∑
      pen.dataInfo.lookPen = ""; // ÁúãÊùøID
      this.penMap[this.mapInfo.penType][nameId] = pen;
      // this.penMap[this.mapInfo.penType].set(nameId, pen);
    },
    // Ëé∑ÂèñnameId
    getNameId() {
      return String(this.nameId++);
    },
    // ÂàùÂßãÂåñÂú∞Âõæ
    initMap() {
      mapInfo.initMap(() => {
        this.addEventListener();
        // mapInfo.myMap.addEventListener("mousemove", function () {});
        // mapInfo.myMap.addEventListener("click", function () {});
      });
    },
    // ÁªòÂà∂ÁÇπÂÆåÊàêÂêéÁöÑÂõûË∞É
    addEventListener() {
      // ÁªòÂà∂Âå∫ÂüüÂêéÁöÑÂõûË∞É
      mapInfo.drawingManager.addEventListener(
        "overlaycomplete",
        (e: { overlay: Pen; drawingMode: string }) => {
          e.overlay.dataInfo = {} as PenDataInfo;
          // typeName = `Â§öËæπÂΩ¢`;
          if (e.drawingMode === "polygon") {
            e.overlay.dataInfo.title = "Ê•ºÊ†ã";
          }
          // typeName = `ÂúÜÂΩ¢`;
          if (e.drawingMode === "circle") {
            e.overlay.dataInfo.title = "ÂúÜÂΩ¢Âå∫Âüü";
          }
          // typeName = `Áü©ÂΩ¢`;
          if (e.drawingMode === "rectangle") {
            e.overlay.dataInfo.title = "Áü©ÂΩ¢Âå∫Âüü";
          }
          // // typeName = `ÁÇπ`;
          // if (e.drawingMode === "marker") {
          // }
          // // typeName = `ÊäòÁ∫ø`;
          // if (e.drawingMode === "polyline") {
          // }
          setTimeout(() => {
            if (this.mapInfo.penType !== "") {
              mapInfo.drawingManager.open();
            }
          }, 100);
          const pen: Pen = e.overlay;
          this.pushPenMap(pen);
        }
      );
      // ÁªòÂà∂ (ÁÇπ / Ê†áÁ≠æ) ÂêéÁöÑÂõûË∞É
      mapInfo.mkrTool.addEventListener("markend", (evt) => {
        const pen: Pen = evt.marker;
        console.log("pen :>> ", pen);
        console.log("evt :>> ", evt);
        pen.dataInfo = {} as PenDataInfo;
        // ÁªòÂà∂ÂõæÊ†á
        if (this.mapInfo.penType === "Marker") {
          const key = this.mapInfo.iconImgId.split("-")[0];
          const img = markerIconList[key].iconList[this.mapInfo.iconImgId];
          pen.dataInfo.title =
            markerIconList[key].iconList[this.mapInfo.iconImgId].label;
          pen.dataInfo.iconImgId = this.mapInfo.iconImgId;
          pen.setTitle(img.label);
        }
        // ÁªòÂà∂Ê†áÁ≠æ
        if (this.mapInfo.penType === "Label") {
          const label = new window.BMap.Label(this.mapInfo.labelInput, {
            offset: new window.BMap.Size(20, 0),
          });
          pen.dataInfo.title = this.mapInfo.labelInput;
          pen.setLabel(label);
          pen.setTitle(this.mapInfo.labelInput);
          // mapInfo.myMap.removeOverlay(pen);
        }
        this.pushPenMap(pen);
      });
    },
    // 	ÂºÄÂßãÁªòÂà∂ÂõæÂÉè
    startPainting(type, off = false) {
      if (type === "") {
        this.mapInfo.penType = "";
        this.mapInfo.iconImgId = "";
        this.mapInfo.labelInput = "";
        mapInfo.drawingManager.close();
        mapInfo.mkrTool.close();
        return;
      } else {
        this.mapInfo.clickSelect = false;
      }
      // Â§öËæπÂΩ¢
      if (type === "Polygon") {
        mapInfo.drawingManager.setDrawingMode(window.BMAP_DRAWING_POLYGON);
      }
      // ÂúÜÂΩ¢
      if (type === "Circle") {
        mapInfo.drawingManager.setDrawingMode(window.BMAP_DRAWING_CIRCLE);
      }
      // Áü©ÂΩ¢
      if (type === "Rectangle") {
        mapInfo.drawingManager.setDrawingMode(window.BMAP_DRAWING_RECTANGLE);
      }
      // ÂõæÊ†áÁÇπ
      if (type === "Marker") {
        const key = this.mapInfo.iconImgId.split("-")[0];
        const img = markerIconList[key].iconList[this.mapInfo.iconImgId];

        const width = 40;
        const size = new window.BMap.Size(width, width);
        const icon = new window.BMap.Icon(`./${img.markerUrl}`, size, {
          imageSize: new window.BMap.Size(width, width),
          anchor: new window.BMap.Size(width / 2, width),
        });
        // mapInfo.mkrTool._opts.followText = `ÈÉ®ÁΩ≤-${img.label}`;
        //ÊâìÂºÄÂ∑•ÂÖ∑
        if (mapInfo.mkrTool.open()) {
          mapInfo.mkrTool.setIcon(icon);
        } else {
          this.mapInfo.penType = "";
          // ÂºÄÂêØÂ§±Ë¥•
        }
      }
      // Ê†áÁ≠æ
      if (type === "Label") {
        const width = 20;
        const size = new window.BMap.Size(width, width);
        const icon = new window.BMap.Icon("./public/drag.png", size, {
          imageSize: new window.BMap.Size(width, width),
          anchor: new window.BMap.Size(width / 2, width),
        });
        // setIcon
        // mapInfo.mkrTool._opts.followText = `${this.mapInfo.labelInput}`;
        //ÊâìÂºÄÂ∑•ÂÖ∑
        if (mapInfo.mkrTool.open()) {
          mapInfo.mkrTool.setIcon(icon);
        } else {
          this.mapInfo.penType = "";
          // ÂºÄÂêØÂ§±Ë¥•
        }
      }
      // ÊòØÂê¶ ÈáçÁΩÆ penType
      if (off) {
        this.mapInfo.penType = type;
        mapInfo.drawingManager.close();
      } else {
        if (this.mapInfo.penType === type) {
          this.mapInfo.penType = "";
          this.mapInfo.iconImgId = "";
          this.mapInfo.labelInput = "";
          mapInfo.drawingManager.close();
          mapInfo.mkrTool.close();
        } else {
          this.mapInfo.penType = type;
          mapInfo.drawingManager.open();
          mapInfo.mkrTool.close();
        }
      }
    },
    // ËÆæÁΩÆÁªëÂÆölabel
    setLabelNameId(pen) {
      if (!pen.dataInfo.labelNameId) {
        return;
      }
      let point = {};
      if (pen.dataInfo.type === "Polygon") {
        point = getCenterPoint(pen.getPath());
      }
      if (pen.dataInfo.type === "Circle") {
        point = pen.getCenter();
      }
      if (pen.dataInfo.type === "Rectangle") {
        point = getCenterPoint(pen.getPath());
      }
      if (pen.dataInfo.type === "Marker") {
        point = pen.getPosition();
      }
      // console.log('pen.dataInfo.labelNameId :>> ', pen.dataInfo.labelIndex);
      this.penMap.Label[pen.dataInfo.labelNameId].setPosition(point);
    },
  },
});
